# Slipstream C/C++ interface

## Overview

The Go compiler has the interesting ability to target embedding Go code within a C/C++ program - with some caveats, of course. This means that a suitable Go API can be called from C code, allowing reuse of code and avoiding rewriting Go libraries for other languages.

This is achieved by adding `-buildmode=c-shared` to the `go build` command. This generates a C header file and an object file which can be easily linked within C/C++ code.

These are the main caveats with embedding Go programs within C/C++:
- The Go API should ideally involve only basic primitive types such as `int`, `float`, etc.
- You cannot easily exchange pointers, or any type which relies on pointers such as slices or structs, from Go to C code. Generally, it is easier for memory to be allocated in C code, and then accessed from a Go helper function.
- There are convenience functions such as `C.CBytes()` and `C.CString()` but these must be used with care to avoid leaking memory.
- A Go function which returns multiple values will end up with auto-generated names for the return variables from the C API, even if they are explicitly named in the Go code.
- This method can only operate on Go code defined within `package main`, along with an empty `func main() {}` function. Therefore, it is likely necessary to create a wrapper file around existing Go libraries.

## Example

This directory contains an example of Go and C/C++ files which could be used to implement Slipstream within a C/C++ environment.

Run `build.sh` to test the interface.

The example involves the following files:
- `c-main.go` is a wrapper file for accessing the Slipstream API from C. It deals with use of `structs` and other types in the Slipstream API which are not directly compatible with the C interface. It maintains a list of active `Enocder` and `Decoder` objects, so that the C code does not need to keep track of these. The C code accesses and interacts with these objects by passing UUIDs. This approach is basic, and it is up to the caller to ensure that duplicate UUIDs are not provided.
- `main.cpp` provides an example of how to use Slipstream from C/C++, for both encoding and decoding. In particular, it shows how to format arguments and return values from the API functions. The example includes two separate tests: batch encoding of an entire message, and iterative sample-by-sample encoding. Batch encoding is more efficient due to fewer function calls, but it is only possible if all data samples are available. The iterative approach might be suitable for streaming data. Note that most of the code in this file is for managing and monitoring tests, and the main parts of interest are the `EncodeAll()`, `Encode()`, `Decode()`, and `GetDecoded()` function calls.
- `c-main.h` is generated by the `go build` command and defines the CC++ API.
- `c-main` is the object file generated by `go build`.

There is some necessary copying of data between the Go and C environments, due to the limitations of the Go interface with C. However, although this is somewhat inefficient, it avoids creating and maintaining a complete rewrite of Slipstream in C, so is a good trade-off.

Note that C++ is used in the example only for accurate timing using `std::chrono`, but the approach should be suitable for integrating with C and C++ code. The build script could use `gcc` instead of `g++` for pure C code.

## Further info

The following links provide useful information about this process:
- https://github.com/vladimirvivien/go-cshared-examples
- https://gist.github.com/helinwang/2c7bd2867ea5110f70e6431a7c80cd9b
- https://stackoverflow.com/questions/43646589/does-passing-a-slice-to-golang-from-c-do-a-memory-copy/43646947#43646947